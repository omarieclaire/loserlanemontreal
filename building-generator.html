<!DOCTYPE html>
<html lang="en">
  <html>
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>LoserLane Building Creator</title>

      <meta name="mobile-web-app-capable" content="yes" />

      <title>Loser Lane Building Generator</title>
      <meta name="title" content="Loser Lane Building Generator" />
      <meta name="description" content="Draw a building for Loser Lane" />

      <!-- Open Graph / Facebook -->
      <meta property="og:type" content="website" />
      <meta property="og:url" content="https://omarieclaire.github.io/loserlanemontreal/" />
      <meta property="og:title" content="Loser Lane Building Generator" />
      <meta property="og:description" content="Draw a building for Loser Lane" />
      <meta property="og:image" content="https://omarieclaire.github.io/loserlanemontreal/img/buildinga.png" />

      <!-- Terrifying creature from the depths Card Tags  -->
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:title" content="Loser Lane Building Generator - Montreal Bike Survival Game" />
      <meta name="twitter:description" content="Draw a building for Loser Lane" />
      <meta name="twitter:image" content="https://omarieclaire.github.io/loserlanemontreal/img/buildinga.png" />

      <link rel="me" href="https://mastodon.social/@omarieclaire" />

      <!-- Bluesky/AT Protocol -->
      <!--  currently use OpenGraph tags, but add these for future compatibility -->
      <meta property="bsky:title" content="Loser Lane Building Generator - Montreal Bike Survival Game" />
      <meta property="bsky:description" content="Draw a building for Loser Lane" />
      <meta property="bsky:image" content="https://omarieclaire.github.io/loserlanemontreal/img/buildinga.png" />

      <!-- General SEO Meta Tags -->
      <meta name="description" content="Draw a building for Loser Lane" />
      <meta name="theme-color" content="#000000" />

      <!-- Image Specifications -->
      <meta property="og:image:width" content="1200" />
      <meta property="og:image:height" content="630" />
      <meta property="og:image:alt" content="Loser Lane Building Generator game preview showing a cyclist navigating through traffic" />

      <link rel="icon" type="image/png" href="/favicon/favicon-96x96.png" sizes="96x96" />
      <link rel="icon" type="image/svg+xml" href="/favicon/favicon.svg" />
      <link rel="shortcut icon" href="/favicon/favicon.ico" />
      <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png" />
      <link rel="manifest" href="/favicon/site.webmanifest" />

      <link rel="stylesheet" href="mainStyles.css" />
      <link rel="stylesheet" href="buildingGeneratorStyles.css" />

      <style></style>
    </head>

    <script src="colours.js"></script>

    <script src="buildings.js"></script>

    <body>
      <!-- Language Toggle -->
      <div class="lang-toggle-container" id="lang-toggle-container">
        <button class="lang-toggle" id="lang-toggle">FR</button>
      </div>

      <div class="info-button-container">
        <button class="info-toggle" id="info-toggle" onclick="toggleInfo()">ℹ</button>
      </div>

      <div class="info-popup" id="info-popup">
        <button class="info-close" onclick="closeInfo()">×</button>
        <p><span data-i18n="infoText"></span> <a href="https://marieflanagan.com/about" target="_blank" rel="noopener">marieflanagan.com</a></p>
      </div>

      <div class="container">
        <h1 data-i18n="title">Draw a building!</h1>
        <p class="subtitle">
          <span data-i18n="subtitle"
            ></span
          >
          <a target="_blank" href="https://omarieclaire.github.io/loserlanemontreal/">LoserLane</a>
        </p>

        <div class="main-content">
          <div class="grid-section">
            <!-- <div class="info-section">
              <span class="current-char-label" data-i18n="currentCharacter">Current Character</span>
              <span class="current-char-display" id="currentCharDisplay">█</span>
            </div> -->

            <div class="grid-container">
              <div class="grid" id="grid"></div>
            </div>
            <div class="controls">
              <button class="btn-clear" onclick="clearGrid()" data-i18n="eraseAll">Clear</button>
              <button class="btn-eraser" id="eraserBtn" onclick="toggleEraser()" data-i18n="eraser">Eraser</button>
              <button class="btn-copy" onclick="loadRandomExample()" data-i18n="example">Example</button>
            </div>
            <button class="btn-add-game" onclick="addToGame()" data-i18n="addButton">Add to LoserLane</button>
          </div>

          <div class="palette-section">
            <div class="palette" id="palette"></div>
          </div>
        </div>

        <div class="community-gallery">
          <h3 data-i18n="recentBuildings">Gallery: Recent Buildings</h3>
          <div class="gallery-scroll" id="galleryScroll"></div>
        </div>
      </div>

      <!-- Modal for adding to game -->
      <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
          <h2 data-i18n="modalTitle">Add to Game</h2>
          <div class="modal-input-group">
            <label data-i18n="buildingName">Building Name</label>
            <input type="text" id="modalBuildingName" data-i18n-placeholder="buildingPlaceholder" placeholder="EG CAFE DEI CAMPI" />
          </div>
          <div class="modal-input-group">
            <label data-i18n="artistName">Your Name / Handle</label>
            <input type="text" id="modalArtistName" data-i18n-placeholder="artistPlaceholder" placeholder="EG OMARIECLAIRE" />
          </div>
          <div class="building-preview-container">
            <div class="building-preview" id="buildingPreview"></div>
          </div>
          <div class="modal-buttons">
            <button class="modal-btn modal-btn-cancel" onclick="closeModal()" data-i18n="cancel">Cancel</button>
            <button class="modal-btn modal-btn-submit" onclick="submitBuilding()" data-i18n="submit">Submit 🚀</button>
          </div>
        </div>
      </div>

      <div class="modal-overlay" id="shareModalOverlay">
        <div class="modal">
          <h2 data-i18n="shareTitle">Success! 🎉</h2>
          <p class="share-message" data-i18n="shareMessage">Your building is on its way to LoserLane! Want to share your creation?</p>
          <div class="building-preview-container">
            <div class="building-preview" id="shareBuildingPreview"></div>
          </div>
          <div class="modal-buttons">
            <button class="modal-btn modal-btn-submit" onclick="shareToTwitter()" data-i18n="shareTwitter">Share on Twitter/X</button>
            <button class="modal-btn modal-btn-submit" onclick="copyShareText()" data-i18n="copyLink">Copy Share Text</button>
            <button class="modal-btn modal-btn-cancel" onclick="closeShareModal()" data-i18n="done">Done</button>
          </div>
        </div>
      </div>
      <div class="toast" id="toast">Copied!</div>

      <!-- Gentle landscape mode hint -->
      <div class="landscape-hint" id="landscapeHint" data-i18n="landscapeHint">Rotate for better experience!</div>

      <script src="translations.js"></script>
      <script src="paletteCategories.js"></script>

      <script>
        const THEME_COLOR = COLOURS.BUILDINGGEN[Math.floor(Math.random() * COLOURS.BUILDINGGEN.length)];

        // Apply theme color to CSS variables
        document.documentElement.style.setProperty("--theme-color", THEME_COLOR);
        document.documentElement.style.setProperty("--theme-color-alpha", THEME_COLOR);

        // Build lookup objects from the array (for performance)
        const LANG = {
          en: {},
          fr: {},
        };

        TRANSLATIONS.forEach((item) => {
          LANG.en[item.key] = item.en;
          LANG.fr[item.key] = item.fr;
        });

        let currentLang = localStorage.getItem("language") || "en";

        // Define the t() function
        function t(key) {
          return LANG[currentLang][key] || key;
        }

        // Language switcher - single toggle button
        document.addEventListener("DOMContentLoaded", () => {
          updateLanguage();

          const langToggle = document.getElementById("lang-toggle");

          if (langToggle) {
            // Set initial button text
            langToggle.textContent = currentLang === "en" ? "FR" : "EN";
            langToggle.addEventListener("click", () => {
              currentLang = currentLang === "en" ? "fr" : "en";
              localStorage.setItem("language", currentLang);
              // Refresh the page to apply new language
              location.reload();
            });
          }
          populateGallery();
        });

        function updateLanguage() {
          document.querySelectorAll("[data-i18n]").forEach((element) => {
            const key = element.dataset.i18n;
            if (LANG[currentLang][key]) {
              element.textContent = LANG[currentLang][key];
            }
          });

          // Update placeholders
          document.querySelectorAll("[data-i18n-placeholder]").forEach((element) => {
            const key = element.dataset.i18nPlaceholder;
            if (LANG[currentLang][key]) {
              element.placeholder = LANG[currentLang][key];
            }
          });
        }

        const GRID_SIZE = 10;
        let grid = Array(GRID_SIZE)
          .fill()
          .map(() => Array(GRID_SIZE).fill(""));
        let currentChar = "█";
        let selectedCell = null;
        let hoveredCell = null;

        let isDrawing = false;
        let lastDrawnCell = null;
        let isEraserMode = false;

        let copiedCell = null;
        let isDraggingToMove = false;
        let draggedCell = null;
        let draggedContent = null;
        let isShiftPressed = false;

        const exampleBuildings = TORONTO_BUILDINGS;
        const paletteCategories = PALETTE_CATEGORIES;

        function copyCell() {
          // Use hoveredCell instead of selectedCell
          const cellIndex = hoveredCell !== null ? hoveredCell : selectedCell;

          if (cellIndex !== null) {
            const row = Math.floor(cellIndex / GRID_SIZE);
            const col = cellIndex % GRID_SIZE;
            copiedCell = grid[row][col];
            // ALSO make it the current stamp!
            currentChar = copiedCell || "";
            selectChar(currentChar);
            showToast(copiedCell ? `Copied: ${copiedCell}` : "Copied empty cell");
          } else {
            showToast("Hover over a cell first!");
          }
        }

        function pasteCell() {
          if (copiedCell === null) {
            showToast("Nothing to paste! Copy a cell first.");
            return;
          }

          // Use hoveredCell instead of selectedCell
          const cellIndex = hoveredCell !== null ? hoveredCell : selectedCell;

          if (cellIndex !== null) {
            const row = Math.floor(cellIndex / GRID_SIZE);
            const col = cellIndex % GRID_SIZE;
            grid[row][col] = copiedCell;
            // Make it the current stamp when we paste
            currentChar = copiedCell;
            selectChar(currentChar);
            updateGrid();
            showToast(copiedCell ? `Pasted: ${copiedCell}` : "Pasted empty cell");
          } else {
            showToast("Hover over a cell first!");
          }
        }

        function initGrid() {
          const gridElement = document.getElementById("grid");
          gridElement.innerHTML = "";

          for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            const cell = document.createElement("div");
            cell.className = "cell";
            cell.dataset.index = i;
            cell.draggable = true;
            // Drag-and-drop handlers
            cell.addEventListener("dragstart", (e) => {
              if (!isShiftPressed) {
                e.preventDefault();
                return;
              }

              isDraggingToMove = true;
              const row = Math.floor(i / GRID_SIZE);
              const col = i % GRID_SIZE;
              draggedCell = i;
              draggedContent = grid[row][col];
              cell.style.opacity = "0.5";
              e.dataTransfer.effectAllowed = "move";
            });

            cell.addEventListener("dragend", (e) => {
              cell.style.opacity = "1";
              draggedCell = null;
              draggedContent = null;
              isDraggingToMove = false;
            });

            cell.addEventListener("dragover", (e) => {
              if (!isDraggingToMove) return;
              e.preventDefault();
              e.dataTransfer.dropEffect = "move";
              cell.style.background = "rgba(99, 248, 99, 0.3)";
            });

            cell.addEventListener("dragleave", (e) => {
              if (!isDraggingToMove) return;
              cell.style.background = "";
            });

            cell.addEventListener("drop", (e) => {
              if (!isDraggingToMove) return;
              e.preventDefault();
              cell.style.background = "";

              if (draggedCell !== null && draggedCell !== i) {
                const fromRow = Math.floor(draggedCell / GRID_SIZE);
                const fromCol = draggedCell % GRID_SIZE;
                const toRow = Math.floor(i / GRID_SIZE);
                const toCol = i % GRID_SIZE;

                // Move the character
                grid[toRow][toCol] = draggedContent;
                grid[fromRow][fromCol] = ""; // Clear source cell

                updateGrid();
                showToast(`Moved: ${draggedContent || "empty"}`);
              }
            });

            // Mouse events for drag-to-paint
            cell.addEventListener("mousedown", (e) => {
              // Only start drawing if Shift is NOT pressed
              if (!isShiftPressed) {
                isDrawing = true;
                lastDrawnCell = null;
                handleCellDraw(i);
              }
            });

            cell.addEventListener("mouseenter", (e) => {
              hoveredCell = i; // Track which cell is hovered

              if (isShiftPressed) {
                cell.style.background = "rgba(99, 248, 99, 0.4)";
                cell.style.transform = "scale(1.05)";
              }

              if (isDrawing && !isShiftPressed && !isDraggingToMove) {
                handleCellDraw(i);
              }
              // Update custom cursor only when not in drag-to-move mode
              if (!isDraggingToMove) {
                updateCellCursor(e.target);
              }
            });

            cell.addEventListener("mouseleave", (e) => {
              hoveredCell = null; // Clear hover tracking
              // Reset cursor
              if (isShiftPressed) {
                e.target.style.background = "";
                e.target.style.transform = "";
              }
              // Reset cursor
              e.target.style.cursor = "";
            });
            cell.addEventListener("click", () => {
              if (!isDraggingToMove) {
                handleCellClick(i);
              }
            });

            cell.addEventListener("contextmenu", (e) => {
              e.preventDefault();
              showContextMenu(e, i);
            });

            // Touch events for mobile
            cell.addEventListener("touchstart", (e) => {
              e.preventDefault();
              isDrawing = true;
              lastDrawnCell = null;
              handleCellDraw(i);
            });

            cell.addEventListener("touchmove", (e) => {
              e.preventDefault();
              if (isDrawing) {
                const touch = e.touches[0];
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                if (element && element.classList.contains("cell")) {
                  const touchIndex = parseInt(element.dataset.index);
                  handleCellDraw(touchIndex);
                }
              }
            });

            gridElement.appendChild(cell);
          }

          // Stop drawing when mouse is released anywhere
          document.addEventListener("mouseup", () => {
            isDrawing = false;
            lastDrawnCell = null;
          });

          // Stop drawing when touch ends
          document.addEventListener("touchend", () => {
            isDrawing = false;
            lastDrawnCell = null;
          });
        }
        function updateCellCursor(cellElement) {
          if (isEraserMode) {
            cellElement.style.cursor =
              'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><text x="2" y="18" font-size="18" font-family="Courier New, monospace" fill="%23999">X</text></svg>\') 12 12, crosshair';
          } else {
            // Create a simple cursor showing just the current character
            const char = currentChar || "█";
            const encodedChar = encodeURIComponent(char);
            cellElement.style.cursor = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><text x="2" y="18" font-size="18" font-family="Courier New, monospace" fill="%23999">${encodedChar}</text></svg>') 12 12, crosshair`;
          }
        }

        function toggleEraser() {
          isEraserMode = !isEraserMode;
          const eraserBtn = document.getElementById("eraserBtn");

          if (isEraserMode) {
            eraserBtn.classList.add("active");
            showToast("Eraser mode activated");
            // Deselect all palette buttons
            document.querySelectorAll(".char-btn").forEach((btn) => {
              btn.classList.remove("selected");
            });
          } else {
            eraserBtn.classList.remove("active");
            showToast("Eraser mode deactivated");
            // Re-select the current character
            selectChar(currentChar);
          }
        }

        function saveToLocalStorage() {
          try {
            localStorage.setItem("loserLaneGrid", JSON.stringify(grid));
            localStorage.setItem("loserLaneLastSaved", new Date().toISOString());
          } catch (e) {
            console.error("Failed to save to localStorage:", e);
          }
        }

        function loadFromLocalStorage() {
          try {
            const savedGrid = localStorage.getItem("loserLaneGrid");
            const lastSaved = localStorage.getItem("loserLaneLastSaved");

            if (savedGrid) {
              const parsedGrid = JSON.parse(savedGrid);

              // More flexible validation - check if it's an array
              if (Array.isArray(parsedGrid) && parsedGrid.length > 0) {
                // Ensure the grid is the correct size, padding if necessary
                grid = Array(GRID_SIZE)
                  .fill()
                  .map((_, i) => {
                    if (parsedGrid[i] && Array.isArray(parsedGrid[i])) {
                      // Pad or trim each row to GRID_SIZE
                      return [...parsedGrid[i].slice(0, GRID_SIZE), ...Array(GRID_SIZE).fill("")].slice(0, GRID_SIZE);
                    }
                    return Array(GRID_SIZE).fill("");
                  });

                updateGrid();
                return true;
              }
            }
          } catch (e) {
            console.error("Failed to load from localStorage:", e);
            // Clear corrupted data
            localStorage.removeItem("loserLaneGrid");
            localStorage.removeItem("loserLaneLastSaved");
          }
          return false;
        }
        // Clear localStorage
        function clearLocalStorage() {
          try {
            localStorage.removeItem("loserLaneGrid");
            localStorage.removeItem("loserLaneLastSaved");
            showToast("Auto-save cleared");
          } catch (e) {
            console.error("Failed to clear localStorage:", e);
          }
        }

        function initPalette() {
          const paletteElement = document.getElementById("palette");

          paletteCategories.forEach((category) => {
            const categoryDiv = document.createElement("div");
            categoryDiv.className = "palette-category";

            const title = document.createElement("div");
            title.className = "palette-title";
            title.textContent = category.name;
            title.setAttribute("data-i18n", category.name);
            categoryDiv.appendChild(title);

            const charsDiv = document.createElement("div");
            charsDiv.className = "palette-chars";

            category.chars.forEach((char) => {
              const btn = document.createElement("button");
              btn.className = "char-btn";
              btn.textContent = char;
              btn.addEventListener("click", () => selectChar(char));
              charsDiv.appendChild(btn);
            });

            categoryDiv.appendChild(charsDiv);
            paletteElement.appendChild(categoryDiv);
          });
        }

        function handleCellClick(index) {
          const row = Math.floor(index / GRID_SIZE);
          const col = index % GRID_SIZE;

          if (isEraserMode) {
            // Erase the cell
            grid[row][col] = "";
            updateGrid();
          } else {
            // If cell has content, pick that character
            if (grid[row][col]) {
              selectChar(grid[row][col]);
            } else {
              // Otherwise, place current character
              grid[row][col] = currentChar;
              updateGrid();
            }
          }

          selectedCell = index;
          highlightCell(index);
        }

        function handleCellDraw(index) {
          // Prevent drawing the same cell multiple times in one drag
          if (lastDrawnCell === index) return;

          const row = Math.floor(index / GRID_SIZE);
          const col = index % GRID_SIZE;

          if (isEraserMode) {
            grid[row][col] = "";
          } else {
            grid[row][col] = currentChar;
          }
          updateGrid();
          lastDrawnCell = index;
        }

        function selectChar(char) {
          currentChar = char;

          // Check if element exists before trying to use it
          const currentCharDisplay = document.getElementById("currentCharDisplay");
          if (currentCharDisplay) {
            currentCharDisplay.textContent = char;
          }

          isEraserMode = false;
          const eraserBtn = document.getElementById("eraserBtn");
          if (eraserBtn) {
            eraserBtn.classList.remove("active");
          }

          // Update palette selection
          document.querySelectorAll(".char-btn").forEach((btn) => {
            btn.classList.toggle("selected", btn.textContent === char);
          });
        }

        function highlightCell(index) {
          document.querySelectorAll(".cell").forEach((cell) => {
            cell.classList.remove("active");
          });
          if (index !== null) {
            document.querySelector(`[data-index="${index}"]`).classList.add("active");
          }
        }

        function updateGrid() {
          document.querySelectorAll(".cell").forEach((cell, index) => {
            const row = Math.floor(index / GRID_SIZE);
            const col = index % GRID_SIZE;
            cell.textContent = grid[row][col];
          });

          // Auto-save after every change
          saveToLocalStorage();
        }

        function loadRandomExample() {
          const exampleBtn = document.querySelector(".btn-copy");
          exampleBtn.classList.remove("first-time");
          localStorage.setItem("exampleClicked", "true");
          // Pick a random example
          const randomIndex = Math.floor(Math.random() * exampleBuildings.length);
          const example = exampleBuildings[randomIndex];

          // Clear the grid first
          grid = Array(GRID_SIZE)
            .fill()
            .map(() => Array(GRID_SIZE).fill(""));

          // Calculate starting row for bottom alignment
          const startRow = GRID_SIZE - example.art.length;

          // Load the example art into the grid (bottom-aligned)
          example.art.forEach((line, artRowIndex) => {
            const gridRowIndex = startRow + artRowIndex;
            for (let colIndex = 0; colIndex < GRID_SIZE; colIndex++) {
              // Get character at this position, default to empty space
              const char = line[colIndex] || "";
              grid[gridRowIndex][colIndex] = char === " " ? "" : char;
            }
          });

          updateGrid();
          selectedCell = null;
          highlightCell(null);
          showToast(`${t("loadedExample")}${example.name} by ${example.artist ? example.artist : getRandomCuteHandle()}!`);
        }

        function getRandomCuteHandle() {
          const cuteHandles = [
            "anonymous_panda",
            "cosmic_koala",
            "digital_bunny",
            "pixel_penguin",
            "creative_owl",
            "melody_kitten",
            "sunny_fox",
            "starry_sloth",
          ];
          return cuteHandles[Math.floor(Math.random() * cuteHandles.length)];
        }

        function clearGrid() {
          grid = Array(GRID_SIZE)
            .fill()
            .map(() => Array(GRID_SIZE).fill(""));
          updateGrid();
          selectedCell = null;
          highlightCell(null);
          clearLocalStorage();

          showToast(t("gridCleared"));
          // if (confirm('Clear your building? This cannot be undone.')) {
          // }
        }

        function getBuildingText() {
          return grid.map((row) => row.join("")).join("\n");
        }

        function addToGame() {
          // Show the modal with building preview
          const previewContainer = document.getElementById("buildingPreview");
          previewContainer.innerHTML = "";
          previewContainer.style.display = "grid";
          previewContainer.style.gridTemplateColumns = "repeat(10, 1fr)";
          previewContainer.style.gap = "2px";
          previewContainer.style.maxWidth = "450px";

          grid.forEach((row) => {
            row.forEach((cell) => {
              const cellDiv = document.createElement("div");
              cellDiv.textContent = cell;
              cellDiv.style.background = "#120303";
              cellDiv.style.color = "#var(--theme-color-alpha)";
              cellDiv.style.aspectRatio = "1 / 1.5";
              cellDiv.style.display = "flex";
              cellDiv.style.alignItems = "center";
              cellDiv.style.justifyContent = "center";
              cellDiv.style.fontSize = "10px";
              cellDiv.style.minHeight = "4px";
              previewContainer.style.gap = "2px";
              previewContainer.appendChild(cellDiv);
            });
          });
          document.getElementById("modalOverlay").classList.add("show");

          // Focus on the first input
          setTimeout(() => {
            document.getElementById("modalBuildingName").focus();
          }, 100);
        }

        function closeModal() {
          document.getElementById("modalOverlay").classList.remove("show");
          document.getElementById("modalBuildingName").value = "";
          document.getElementById("modalArtistName").value = "";
        }

        function submitBuilding() {
          let buildingName = document.getElementById("modalBuildingName").value.trim();
          let artistName = document.getElementById("modalArtistName").value.trim();

          if (!buildingName) {
            showToast(t("enterBuildingName"));
            document.getElementById("modalBuildingName").focus();
            return;
          }

          if (!artistName) {
            showToast(t("enterArtistName"));
            document.getElementById("modalArtistName").focus();
            return;
          }

          // Check character limits
          if (buildingName.length > 30) {
            showToast(t("buildingNameTooLong"));
            document.getElementById("modalBuildingName").focus();
            return;
          }

          if (artistName.length > 30) {
            showToast(t("artistNameTooLong"));
            document.getElementById("modalArtistName").focus();
            return;
          }

          // Remove spaces from inputs (as per form requirements)
          buildingName = buildingName.replace(/\s+/g, "_").toUpperCase();
          artistName = artistName.replace(/\s+/g, "_");

          // Trim empty rows from top and bottom
          let trimmedGrid = [...grid];

          // Remove empty rows from top
          while (trimmedGrid.length > 0 && trimmedGrid[0].every((cell) => cell === "")) {
            trimmedGrid.shift();
          }

          // Remove empty rows from bottom
          while (trimmedGrid.length > 0 && trimmedGrid[trimmedGrid.length - 1].every((cell) => cell === "")) {
            trimmedGrid.pop();
          }

          // Generate the art array - each line is exactly GRID_SIZE (10) characters
          const artLines = trimmedGrid.map((row) => {
            // Convert empty strings to spaces, then join
            const line = row.map((cell) => (cell === "" ? " " : cell)).join("");
            // Ensure line is exactly GRID_SIZE characters by padding with spaces
            const paddedLine = line.padEnd(GRID_SIZE, " ");
            return `            "${paddedLine}"`;
          });

          // Create the complete JavaScript object format
          const formattedObject = `    {
                name: "${buildingName}",
                artist: "${artistName}",
                art: [
        ${artLines.join(",\n")}
                ]
            },`;

          // Prepare form data for Google Form submission
          const formData = new URLSearchParams();
          formData.append("entry.1432455807", "Montreal"); // Location (default Montreal)
          formData.append("entry.540203602", buildingName); // Building_Name
          formData.append("entry.1023700221", artistName); // Your Name or Handle
          formData.append("entry.1869243340", formattedObject); // Your art! (full formatted object)

          // Submit to Google Form
          fetch("https://docs.google.com/forms/d/e/1FAIpQLSeI6SFIJq0mfRlNYxAKm-36wQas02aU5HM4EyQZiIhEKZhdag/formResponse", {
            method: "POST",
            mode: "no-cors",
            body: formData,
          })
            .then(() => {
              closeModal();
              showShareOptions(buildingName, artistName);

              showToast(t("submitSuccess"));

              // Optional: Clear the grid after successful submission
              // setTimeout(() => clearGrid(), 1000);
            })
            .catch((error) => {
              closeModal();
              showToast(t("submitFailed"));
              console.error("Submission error:", error);
            });
        }

        // Context menu functionality
        let contextMenuElement = null;

        function showContextMenu(e, cellIndex) {
          // Remove any existing context menu
          if (contextMenuElement) {
            contextMenuElement.remove();
          }

          // Create context menu
          contextMenuElement = document.createElement("div");
          contextMenuElement.style.position = "fixed";
          contextMenuElement.style.top = e.clientY + "px";
          contextMenuElement.style.left = e.clientX + "px";
          contextMenuElement.style.backgroundColor = "white";
          contextMenuElement.style.border = "1px solid #ccc";
          contextMenuElement.style.borderRadius = "4px";
          contextMenuElement.style.boxShadow = "0 2px 8px rgba(0,0,0,0.15)";
          contextMenuElement.style.zIndex = "10000";
          contextMenuElement.style.minWidth = "140px";
          contextMenuElement.style.padding = "4px 0";

          // Copy option
          const copyBtn = document.createElement("button");
          copyBtn.textContent = "Copy (C)";
          copyBtn.style.cssText =
            "display:block; width:100%; padding:8px 12px; border:none; background:none; text-align:left; cursor:pointer; font-size:14px;";
          copyBtn.onmouseover = () => (copyBtn.style.backgroundColor = "#f0f0f0");
          copyBtn.onmouseout = () => (copyBtn.style.backgroundColor = "transparent");
          copyBtn.onclick = () => {
            const row = Math.floor(cellIndex / GRID_SIZE);
            const col = cellIndex % GRID_SIZE;
            copiedCell = grid[row][col];
            currentChar = copiedCell || "";
            selectChar(currentChar);
            showToast(copiedCell ? `Copied: ${copiedCell}` : "Copied empty cell");
            contextMenuElement.remove();
          };

          // Paste option
          const pasteBtn = document.createElement("button");
          pasteBtn.textContent = "Paste (V)";
          pasteBtn.disabled = copiedCell === null;
          pasteBtn.style.cssText = `display:block; width:100%; padding:8px 12px; border:none; background:none; text-align:left; cursor:${
            copiedCell === null ? "not-allowed" : "pointer"
          }; font-size:14px; opacity:${copiedCell === null ? "0.5" : "1"};`;
          if (copiedCell !== null) {
            pasteBtn.onmouseover = () => (pasteBtn.style.backgroundColor = "#f0f0f0");
            pasteBtn.onmouseout = () => (pasteBtn.style.backgroundColor = "transparent");
          }
          pasteBtn.onclick = () => {
            if (copiedCell !== null) {
              const row = Math.floor(cellIndex / GRID_SIZE);
              const col = cellIndex % GRID_SIZE;
              grid[row][col] = copiedCell;
              currentChar = copiedCell;
              selectChar(currentChar);
              updateGrid();
              showToast(copiedCell ? `Pasted: ${copiedCell}` : "Pasted empty cell");
            }
            contextMenuElement.remove();
          };

          // Clear option
          const clearBtn = document.createElement("button");
          clearBtn.textContent = "Clear (X)";
          clearBtn.style.cssText =
            "display:block; width:100%; padding:8px 12px; border:none; background:none; text-align:left; cursor:pointer; font-size:14px;";
          clearBtn.onmouseover = () => (clearBtn.style.backgroundColor = "#f0f0f0");
          clearBtn.onmouseout = () => (clearBtn.style.backgroundColor = "transparent");
          clearBtn.onclick = () => {
            const row = Math.floor(cellIndex / GRID_SIZE);
            const col = cellIndex % GRID_SIZE;
            grid[row][col] = "";
            updateGrid();
            showToast("Cleared cell");
            contextMenuElement.remove();
          };

          contextMenuElement.appendChild(copyBtn);
          contextMenuElement.appendChild(pasteBtn);
          contextMenuElement.appendChild(clearBtn);
          document.body.appendChild(contextMenuElement);

          // Close menu when clicking outside
          setTimeout(() => {
            document.addEventListener("click", closeContextMenu);
          }, 0);
        }

        function closeContextMenu() {
          if (contextMenuElement) {
            contextMenuElement.remove();
            contextMenuElement = null;
          }
          document.removeEventListener("click", closeContextMenu);
        }

        function showToast(message) {
          const toast = document.getElementById("toast");
          toast.textContent = message;
          toast.classList.add("show");
          setTimeout(() => {
            toast.classList.remove("show");
          }, 2500);
        }

        // Keyboard support
        document.addEventListener("keyup", (e) => {
          if (e.key === "Shift") {
            isShiftPressed = false;
            isDraggingToMove = false;
            // Remove visual indicator
            document.querySelectorAll(".cell").forEach((cell) => {
              cell.style.borderColor = "";
              cell.style.borderWidth = "";
              cell.style.borderStyle = "";
            });
          }
        });

        document.addEventListener("keydown", (e) => {
          if (e.key === "Shift") {
            isShiftPressed = true;
            // Add visual indicator to show shift-drag mode is active
            document.querySelectorAll(".cell").forEach((cell) => {
              cell.style.borderColor = "rgba(99, 248, 99, 0.3)";
              cell.style.borderWidth = ".5px";
              cell.style.borderStyle = "solid";
            });
          }
          // Handle modal keyboard shortcuts
          if (document.getElementById("modalOverlay").classList.contains("show")) {
            if (e.key === "Enter") {
              submitBuilding();
              e.preventDefault();
            } else if (e.key === "Escape") {
              closeModal();
              e.preventDefault();
            }
            return;
          }

          if (selectedCell === null) {
            selectedCell = 0;
            highlightCell(0);
          }

          const row = Math.floor(selectedCell / GRID_SIZE);
          const col = selectedCell % GRID_SIZE;

          // Handle C for copy (on hovered cell, no Ctrl needed)
          if (e.key.toLowerCase() === "c" && !e.ctrlKey && !e.metaKey) {
            copyCell();
            e.preventDefault();
          }
          // Handle V for paste (on hovered cell, no Ctrl needed)
          else if (e.key.toLowerCase() === "v" && !e.ctrlKey && !e.metaKey) {
            pasteCell();
            e.preventDefault();
          }
          // Also support Ctrl+C and Ctrl+V for compatibility
          else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "c") {
            copyCell();
            e.preventDefault();
          } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "v") {
            pasteCell();
            e.preventDefault();
          }
          // Handle arrow keys
          else if (e.key === "ArrowUp" && row > 0) {
            selectedCell -= GRID_SIZE;
            highlightCell(selectedCell);
            e.preventDefault();
          } else if (e.key === "ArrowDown" && row < GRID_SIZE - 1) {
            selectedCell += GRID_SIZE;
            highlightCell(selectedCell);
            e.preventDefault();
          } else if (e.key === "ArrowLeft" && col > 0) {
            selectedCell--;
            highlightCell(selectedCell);
            e.preventDefault();
          } else if (e.key === "ArrowRight" && col < GRID_SIZE - 1) {
            selectedCell++;
            highlightCell(selectedCell);
            e.preventDefault();
          }
          // Handle backspace/delete - acts as eraser
          else if (e.key === "Backspace" || e.key === "Delete") {
            grid[row][col] = "";
            updateGrid();
            e.preventDefault();
          }

          // Handle space to place current character
          else if (e.key === " ") {
            if (isEraserMode) {
              grid[row][col] = "";
            } else {
              grid[row][col] = currentChar;
            }
            updateGrid();
            e.preventDefault();
          }
          // Handle any printable character
          else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
            selectChar(e.key);
            grid[row][col] = e.key;
            updateGrid();
            e.preventDefault();
          }
        });
        // Initialize
        document.addEventListener("DOMContentLoaded", () => {
          initGrid();
          initPalette();
          selectChar(currentChar);

          // Try to load from localStorage on startup
          const loaded = loadFromLocalStorage();
          if (!loaded) {
            // If nothing was loaded, make sure grid is displayed
            updateGrid();
          }

          const exampleBtn = document.querySelector(".btn-copy");
          if (!localStorage.getItem("exampleClicked")) {
            exampleBtn.classList.add("first-time");
          }
        });

        // Gentle landscape mode hint - shows once on mobile portrait
        function showLandscapeHint() {
          // Only show on mobile-sized screens in portrait orientation
          const isMobile = window.innerWidth <= 768;
          const isPortrait = window.innerHeight > window.innerWidth;

          if (isMobile && isPortrait) {
            const hint = document.getElementById("landscapeHint");

            // Show the hint after a brief delay
            setTimeout(() => {
              hint.classList.add("show");
              hint.textContent = t("landscapeHint");

              // Hide after 3 seconds
              setTimeout(() => {
                hint.classList.remove("show");
              }, 4000);
            }, 500);

            // Mark that we've shown it
            localStorage.setItem("landscapeHintShown", "true");
          }
        }

        function populateGallery() {
          const galleryElement = document.getElementById("galleryScroll");
          if (!galleryElement) return;

          // Show last 10 examples
          const recentBuildings = exampleBuildings.slice(-10).reverse();

          recentBuildings.forEach((building) => {
            const item = document.createElement("div");
            item.className = "gallery-item";

            // Pick a random color for this building
            const buildingColor = COLOURS.BUILDINGGEN[Math.floor(Math.random() * COLOURS.BUILDINGGEN.length)];

            const buildingDiv = document.createElement("div");
            buildingDiv.className = "gallery-building";
            buildingDiv.style.color = buildingColor;

            // Calculate how many empty rows to add at the top for bottom alignment
            const emptyRows = GRID_SIZE - building.art.length;

            // Render exactly like the game does - as text with inline-block spans
            let buildingHTML = "";

            // Add empty rows at the top
            for (let rowNum = 0; rowNum < emptyRows; rowNum++) {
              for (let i = 0; i < 10; i++) {
                buildingHTML += `<span style="display: inline-block; width: 0.6em; text-align: center;"> </span>`;
              }
              buildingHTML += "\n";
            }

            // Add the actual building art
            building.art.forEach((line) => {
              // Each character gets wrapped in a span with width: 0.6em
              for (let i = 0; i < 10; i++) {
                const char = line[i] || " ";
                buildingHTML += `<span style="display: inline-block; width: 0.6em; text-align: center;">${char}</span>`;
              }
              buildingHTML += "\n";
            });

            buildingDiv.innerHTML = buildingHTML;

            // Info section with building and artist name
            const infoDiv = document.createElement("div");
            infoDiv.className = "gallery-info";

            const buildingName = document.createElement("div");
            buildingName.className = "gallery-building-name";
            buildingName.textContent = building.name;

            const artistName = document.createElement("div");
            artistName.className = "gallery-artist-name";
            artistName.textContent = `by ${building.artist || "Anonymous"}`;

            infoDiv.appendChild(buildingName);
            infoDiv.appendChild(artistName);

            item.appendChild(buildingDiv);
            item.appendChild(infoDiv);

            // Click to load this building
            item.onclick = () => {
              loadSpecificExample(building);
              showToast(`Loaded: ${building.name}`);
            };

            galleryElement.appendChild(item);
          });
        }
        function loadSpecificExample(building) {
          grid = Array(GRID_SIZE)
            .fill()
            .map(() => Array(GRID_SIZE).fill(""));
          const startRow = GRID_SIZE - building.art.length;

          building.art.forEach((line, artRowIndex) => {
            const gridRowIndex = startRow + artRowIndex;
            for (let colIndex = 0; colIndex < GRID_SIZE; colIndex++) {
              const char = line[colIndex] || "";
              grid[gridRowIndex][colIndex] = char === " " ? "" : char;
            }
          });

          updateGrid();
        }

        // Show hint after page loads
        window.addEventListener("load", showLandscapeHint);
      </script>

      <script>
        let currentShareData = {};

        function showShareOptions(buildingName, artistName) {
          currentShareData = { buildingName, artistName };

          // Render the building preview
          const previewContainer = document.getElementById("shareBuildingPreview");
          previewContainer.innerHTML = "";
          previewContainer.style.display = "grid";
          previewContainer.style.gridTemplateColumns = "repeat(10, 1fr)";
          previewContainer.style.gap = "2px";

          grid.forEach((row) => {
            row.forEach((cell) => {
              const cellDiv = document.createElement("div");
              cellDiv.textContent = cell;
              cellDiv.style.background = "#120303";
              cellDiv.style.color = "var(--theme-color-alpha)";
              cellDiv.style.aspectRatio = "1 / 1.5";
              cellDiv.style.display = "flex";
              cellDiv.style.alignItems = "center";
              cellDiv.style.justifyContent = "center";
              cellDiv.style.fontSize = "10px";
              previewContainer.appendChild(cellDiv);
            });
          });

          document.getElementById("shareModalOverlay").classList.add("show");
        }

        function closeShareModal() {
          document.getElementById("shareModalOverlay").classList.remove("show");
          clearGrid(); // Clear after sharing
        }

        function shareToTwitter() {
          const text = `I just added "${currentShareData.buildingName}" to LoserLane Montreal! 🏙️✨ Draw your own building: https://omarieclaire.github.io/loserlanemontreal/ @omarieclaire`;
          const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
          window.open(url, "_blank");
        }

        function copyShareText() {
          const text = `I just added "${currentShareData.buildingName}" to LoserLane Montreal! 🏙️✨ Check it out: https://omarieclaire.github.io/loserlanemontreal/`;
          navigator.clipboard.writeText(text).then(() => {
            showToast("Share text copied! 📋");
          });
        }
      </script>

      <script>
        function toggleInfo() {
          const popup = document.getElementById("info-popup");
          popup.classList.toggle("show");
        }

        function closeInfo() {
          document.getElementById("info-popup").classList.remove("show");
        }

        // Close info popup when clicking outside - add this with the other event listeners
        document.addEventListener("click", (e) => {
          const popup = document.getElementById("info-popup");
          const button = document.getElementById("info-toggle");
          if (popup && button && popup.classList.contains("show")) {
            if (!popup.contains(e.target) && e.target !== button) {
              popup.classList.remove("show");
            }
          }
        });
      </script>
    </body>
  </html>
</html>
